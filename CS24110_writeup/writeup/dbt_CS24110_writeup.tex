\documentclass[journal,transmag]{IEEEtran}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{subfigure}
\usepackage{booktabs}
\usepackage{url}
\usepackage{breakurl}
\usepackage[breaklinks]{hyperref}

\begin{document}

\def\UrlBreaks{\do\/\do-}

%
% paper title
% Titles are generally capitalized except for words such as a, an, and, as,
% at, but, by, for, in, nor, of, on, or, the, to and up, which are usually
% not capitalized unless they are the first or last word of the title.
% Linebreaks \\ can be used within to get better formatting as desired.
% Do not put math or special symbols in the title.
%WRITE CORRECT BLUR FILTER
\title{CS24110 Assignment: Automatic Enhancement of Digital Images via Automatic Contrast Adjustment on RGB, Histogram Equalisation on LAB Colour Space, and Average Value Blur Filter}


% author names and affiliations
% transmag papers use the long conference author name format.

\author{\IEEEauthorblockN{Dimitar Tasev}
\IEEEauthorblockA{Department of Computer Science, Aberystwyth University, Aberystwyth, SY23 3DB, UK}}% <-this % stops an unwanted space

% The paper headers
\markboth{CS24110}%
{D. Tasev}

\IEEEtitleabstractindextext{%
	

%TODO write abstract last, summarise whole paper
% Your abstract goes in here
\begin{abstract}
This paper presents a novel approach to image enhancement based on the alignment of an image's intensity profile to a specified ideal value.  This mid-mean alignment algorithm is easy to understand and fast to compute.  The algorithm is tested on five test images and the results show that, in some circumstances, the algorithm is able to improve the quality of an image.  However, the algorithm does contain some properties which means that the results may not always be satisfactory.  These aspects are discussed in this paper alongside possible points for improvement.
\end{abstract}

}



% make the title area
\maketitle

\IEEEdisplaynontitleabstractindextext

%TODO
%what is image processing
%what is it used for/why is it useful
%what is the assignment problem
%what is enhancement?
%how did we go on solving it

\section{Introduction}

% The very first letter is a 2 line initial drop letter followed
% by the rest of the first word in caps.
% 
% form to use if the first word consists of a single letter:
% \IEEEPARstart{A}{demo} file is ....
% 
% form to use if you need the single drop letter followed by
% normal text (unknown if ever used by IEEE):
% \IEEEPARstart{A}{}demo file is ....
% 
% Some journals put the first two words in caps:
% \IEEEPARstart{T}{his demo} file is ....
% 
% Here we have the typical use of a "T" for an initial drop letter
% and "HIS" in caps to complete the first word.
\IEEEPARstart{T}{he} increased use of computers, along with the rise in social networks and the ubiquitous nature of digitals cameras means that society is experiencing a flood of digital images.  Twenty years ago, digital cameras and digital image processing was still the domain of the professional; however, now nearly everyone has a camera in their phone and most programs that deal with digital images have some kind of image processing aspect. 

The ability to alter, or manipulate, an image is not something that is new in the digital age.  Developers of traditional film camera photos were able to modify their images in the dark room, a technical and often laborious task.  In contrast, editing photographs in the digital age could not be simpler.  Dedicated programs such as Adobe\textsuperscript{\texttrademark} Photoshop\textsuperscript{\textregistered} or Gimp\footnote{\url{http://www.gimp.org}} allow anyone to quickly and easily modify their images.  These programs contain sophisticated algorithms to change the tone, colour, brightness, contrast, and many other aspects of the image.  They also allow for multiple images to be ``merged'' and so the rise of the term ``Photoshopping an image'', meaning to alter the image's content in some way.

Although the algorithms in these software suites are powerful, more often than not they require some form of user input to guide the image modification process.  Some products contain auto enhancement methods, but the ability to automatically enhance an image without any user input is still an ongoing area of research.

In recent times, this area of auto-enhancement has taken a different direction due to the rise of the social network Instagram\textsuperscript{\texttrademark}.  Whereas, ``Photoshopping'' became synonymous with editing a photogram, Instagram has become synonymous with automatically enhanced images through the use of an Instagram filter.  These filters will often produce extreme effects so that the image appears like an old Polaroid camera, or is changed to a high contrast black and white image.  Whatever method is used the process is the same: alter the image in a specified way to produce a new, enhanced, image.

This paper is concerned with a new method to enhance a given image without any use input.  The basic idea behind the approach is to match the intensity of the input image so that it is aligned to the middle intensity value.  In theory, this should correct any brightness defects in the image.

The remainder of the paper is organised as follows: in Section \ref{sec:methods} the methodology of the approach is given at both a high and low level.  The results are given in Section \ref{sec:results} and then discussions and conclusions are drawn in Section \ref{sec:discussion}.

%TODO change to 
\begin{figure}[h!]
\centering
\includegraphics[width=0.42\textwidth]{figures/flowchart.png}
\caption{A flowchart of the proposed enhancement method. It shows the steps that will be performed in the automatic enhancement.}
\label{fig:flowchart}
\end{figure}

\section{Methodology}
\label{sec:methods}

% Blur Filter >
%  RGB TO LAB, 
% Histogram Equalisation, 
% Lab to RGB, 
% Contrast Adjustment
In this section the methods behind the Average Value Blur Filter, Colour Space Conversion, Histogram Equalisation, and Contrast Adjustment is described. A high-level overview of how the method works, a mathematical outline and pseudocode are also provided.
%In this section the methodology behind the mean matching approach to image enhancement is described.  As well as a high-level overview of how the method works, a mathematical outline and pseudocode are also provided.

\subsection{High-level Overview}
The idea behind the proposed automatic enhancement approach is to do a contrast adjustment to remap the intensity value so that the whole range of possible values is used, convert to LAB(CIELAB) colour space and perform a Histogram Equalisation on the Luminosity channel to enhance the picture, then convert back to RGB, and apply an Average Value Blur Filter for noise removal. The enhancement will follow the flowchart on figure \ref{fig:flowchart}.

\begin{figure}[h!]
\centering
\includegraphics[width=0.42\textwidth]{figures/contrAdj.png}
\caption{An image showing how the range of values will be set when applying contrast adjustment to the picture.}
\label{fig:contrAdj}
\end{figure}

\begin{algorithm}[bh!] %normal hist
	\caption{Normal Histogram}
	\label{alg:norm_hist}
	\begin{algorithmic}[1]
		\Function{NormalHistogram} {$I$}\Comment{where $| I | = m \times n$, \\ $K = $ MAX value of the colour space, 256 for RGB, 101 for LAB's L channel}
		\State
		\State $H = [0, K-1]$
		\State 
		\For{\textbf{each} $p$ \textbf{in} $I$} 
		\State $H(p) = H(p) + 1$
		\EndFor
		\State 
		\State
		\Return $H$
		\EndFunction
	\end{algorithmic}
\end{algorithm}
\begin{algorithm}[bh!]%cumulative hist
	\caption{Cumulative Histogram}
	\label{alg:cum_hist}
	\begin{algorithmic}[1]
		\Function{CumulativeHistogram} {$I$}\\ \Comment{where $K = $ MAX value of the colour space, 256 for RGB, 101 for LAB's L channel}
		\State
		\State $H = $ NormalHistogram()
		\State $CH = [0, K-1]$
		\State
		\For{\textbf{each} $v$ \textbf{in} $H$} 
		\State $CH[v] = CH[v-1] + H[v]$
		\EndFor
		\State 
		\State
		\Return $CH$
		\EndFunction
	\end{algorithmic}
\end{algorithm}

\subsection{Detailed Description}
%FORLATER average filter might be very strong on small pictures, and very weak on big pictures, since pictures are smallish, it's very noticeable and it blurs them a lot
The proposed enhancement algorithm is a combination of filter and point-based histogram operations. To simplify the description of the operations, the algorithm assumes that the picture is grayscale, however the final algorithm works on RGB images, by repeating the functions for each colour channel. 
\begin{figure}[t] % normal and cumulative histograms 
	\centering
	\subfigure[original] {
		\includegraphics[width=0.2\textwidth]{figures/norm_hist.png}
	}
	\subfigure[modified] {
		\includegraphics[width=0.2\textwidth]{figures/cum_hist.png}
	}
	\caption{Two images showing a normal histogram and a cumulative histogram of it.}
	\label{fig:hist_comp}
\end{figure}
The first two operations both rely on histograms to perform their operations. A histogram is a graphical representation of a distribution of numerical data\cite{histDesc}\cite{histDescWiki}. Figure \ref{fig:hist_comp} shows both a normal histogram and a cumulative histogram, both of which are used. The pseudocode for creating a \textbf{normal histogram} \ref{alg:norm_hist}, and the pseudocode for creating a \textbf{cumulative histogram} from the normal histogram \ref{alg:cum_hist} are included in the paper. The equation for deriving a cumulative histogram from a normal histogram can be simply written as: 

\begin{equation}%equation for cumulative histogram
\begin{aligned}
H(i) &=  \sum_{j = 0}^{i}h(j) 
& for(0 \leq i < K)
\end{aligned}
\end{equation}
\begin{figure}[h!] % normal and contrast adjusted histograms 
	\centering
	\subfigure[original] {
		\includegraphics[width=0.2\textwidth]{figures/pre_contr_adj.png}
	}
	\subfigure[modified] {
		\includegraphics[width=0.2\textwidth]{figures/post_contr_adj.png}
	}
	\caption{Two images showing a normal histogram before and after being contrast adjusted.}
	\label{fig:contrAdjustedHist}
\end{figure}

The second operation, the Contrast Adjustment, is performed on the image in RGB colour space, so no conversion is needed. In images often the full range of values isn't used. Automatic contrast adjustment remaps the intensity values so that they occupy the full range of possible values\cite{automaticContrast}. We have to identify two quantiles at the low $p'_{low}$ and high $p'_{high}$ end of the intensity spectrum, and map the pixel values inside them to the extreme values, the other pixels are then linearly mapped to the interval [$p_{min}, p_{max}$] \ref{fig:contrAdj}. To calculate the two quantiles we set a range for ignored pixels $q$. Using that range we can calculate the quantiles using the cumulative histogram:

\begin{equation} %equation for getting the P value for contr adjustment
\begin{aligned}\label{eq:contrAdjPlowNPhigh}
&p'_{low} = \min\{i | CH(i) \geq m\cdot n \cdot q_{low}\}\\
&p'_{high} = \max\{i \text{ } | CH(h) \leq m\cdot n \cdot q_{high}\}
\end{aligned}
\end{equation}

\noindent Given that q follows: 
\begin{equation}\label{eq:contrAdjQcalc}
0 \leq q_{low}, q_{high} \leq 1, q_{low} + q_{high} \leq 1
\end{equation}

\noindent After applying the formula to the cumulative histogram we will get ranges, which can be visually represented like this:
\begin{center}
	 \includegraphics[width=0.2\textwidth]{figures/cum_hist_range.png}
	 \label{fig:cumulativeHistRange}
\end{center}
Then we loop through the pixels in the picture and apply the following function $f$ to each pixel: 

\begin{center}
	\includegraphics[width=0.5\textwidth]{figures/contrAdjFormula.png}
	\label{fig:contrAdjFunc}
\end{center}

\noindent We can see the difference in the histograms after adjusting the contrast \ref{fig:contrAdjustedHist}, the value range now occupies the whole spectrum of possible intensities.
%\begin{equation}
%\begin{aligned}
%\[
%	f(x) = 
%	\begin{cases}
%	p_{min}, &\text{for } p \leq p'_{low}\\
%	p_{min} + (p - p'_{low})\cdot \frac{p_{max}-p_{min}}{p'_{high}-p'{low}}, &\text{for } p'_{low} < p < p'_{high}\\
%	p_{max}, &\text{for } p \geq p'_{high}
%	\end{cases}
	
%\]
%\end{aligned}
%\end{equation}


The last operation of the algorithm is Histogram Equalisation on the Luminosity channel in LAB(CIELAB) colour space. It adjusts the contrast and brightness to appear as they would in a well exposed picture. As we can see in Figure \ref{fig:luminDiffHist}, if the brightness of the picture is low, i.e. the picture is dim, the Luminosity channel is concentrated in the lower end of the spectrum. If the picture is bright, it is concentrated in the high end of the spectrum. In order to equalise the Luminosity channel, we first have to convert the image to LAB. This cannot be done directly, so the RGB picture has to be converted to XYZ colour\cite{rgbTOxyz} space first, and then converted to LAB\cite{xyzTOlab}. Then a normal and cumulative histograms have to be created on the Luminosity (L) channel, using the methods described earlier \ref{alg:norm_hist}, \ref{alg:cum_hist}. From the cumulative histogram we can equalise the pixel distribution, so that the histogram of the image approximates a uniform distribution. The goal of histogram equalisation is to shift the pixels in the image, so that the resulting cumulative histogram is approximately linear. \cite{automaticContrast} Figure \ref{fig:equal_hist} is showing the cumulative histogram of the L channel before equalisation, and after equalisation. Histogram equalisation on the cumulative histogram is done using the algorithm \ref{alg:equal_hist}, implementing the following equation: 
\begin{equation}
f_{he}(p) = \lfloor CH(p) \cdot \frac{K - 1}{mn}\rfloor
\end{equation}
\noindent After the Equalised Histogram has been created, we have to loop through each pixel in the image and set its new value, which is stored in the Equalised Histogram, at the position of the pixel's current value: 
\begin{equation}\label{eq:histEqPixel}
P(v) = EQH(P(v))
\end{equation}
\begin{algorithm}[h!] %histogram equalisation
	\caption{Histogram Equalisation}
	\label{alg:equal_hist}
	\begin{algorithmic}[1]
		\Function{HistogramEqualisation} {$I$}\\ \Comment{where $K = $ MAX value of the colour space, 256 for RGB, 101 for LAB's L channel}
		\State
		\State $CH =$ CumulativeHistogram(I)
		\State $EQH = [0, K-1]$
		\State
		\For{\textbf{each} $v$ \textbf{in} $CH$} 
		\State $EQH(v) = CH(v)\cdot\frac{K-1}{m \times n}$
		\EndFor
		\State 
		\State
		\Return $EQH$
		\EndFunction
	\end{algorithmic}
\end{algorithm}
\begin{figure}
		\centering
		\subfigure[original] {
			\includegraphics[width=0.2\textwidth]{figures/cum_labhist.png}
		}
		\subfigure[modified] {
			\includegraphics[width=0.2\textwidth]{figures/equal_labhist.png}
		}
		\caption{Two images showing a normal histogram and the equalised histogram of it.}
		\label{fig:equal_hist}
\end{figure}
%TODO histogram equalisation PseudoCode space == available ? write : dont write 

The last operation in the algorithm, the Average Value Blur is a filter, because it does not rely solely on a single pixel's value. The filter loops through the picture and acts on each pixel, but in the calculation the values of the neighbouring pixels are also included. Its effect is to reduce the noise in the picture, by applying a blur effect.\cite{averageFilter} The strength of the blur, however, heavily depends on the size of the picture. Small pictures (i.e. 640x480 resolution) will have very strong blur, to the point of ruining the picture, and very big pictures (i.e. 1920x1020 resolution) will have nearly no visible change. The described filter operation acts on each channel in the same manner, using a filter operation function $f$. That is: 
%TODO add pseudo code?

\begin{equation}\label{eq:avgFilter} %equation that shows filter calculation
I'(u, v) = f(\frac{1}{9}\cdot\sum_{j=-1}^{1}\sum_{i=-1}^{1}I(u+i, v+j))
\end{equation}

\subsection{Implementation}
The detailed description section focuses on a single colour channel; however, since the algorithm needs to work on RGB images, the above methods needs to be repeated for each of the colour channels. The three enhancement operations are used in sequence in the image enhancement algorithm. Each of them will be looked at separately, in the order that they are applied in the algorithm, because if the order is changed, the final result will also be different. At the end of each of the operations, a clamping operation will be used to ensure that the modified intensities do not fall out of the displayable range.

The first operation is \textbf{Automatic Contrast Adjustment} on the RGB channel. To achieve that the implementation will create and store a Normal Histogram \ref{alg:norm_hist} for each of the channels. When the Normal Histograms have been calculated, we can use them to create the Cumulative Histograms \ref{alg:cum_hist}, repeated for each of the channels. Then we have to pick appropriate $q_{low}$ and $q_{high}$, following the equation \ref{eq:contrAdjQcalc}. Now we can calculate $p'_{low}$ and $p'_{high}$ for each of the colour channels using the Cumulative Histograms of the channels \ref{eq:contrAdjPlowNPhigh}. After we have calculated $p'_{low}$ and $p'_{high}$, we apply the function \ref{fig:contrAdjFunc} to each pixel to determine it's new value. After the Contrast Adjusted image is produced, we perform the second operation from the algorithm, the Luminosity Histogram Equalisation.

In order to create a \textbf{histogram} on the \textbf{Luminosity channel}, we have to convert each pixel to LAB colour space, before performing any operations. As this cannot be done directly from RGB, we first need to convert it into XYZ \cite{rgbTOxyz} colour space, and then into LAB \cite{xyzTOlab} colour space. The implementation has to loop through each pixel, converting it to LAB colour space, and creating a Normal Histogram \ref{alg:norm_hist} of the Luminosity (L channel for short). When the Normal Histogram is calculated, a Cumulative Histogram \ref{alg:cum_hist} is created from it, and finally an equalisation \ref{alg:equal_hist} is performed on the Cumulative Histogram. After the Equalised Histogram has been completed, the implementation loops through all of the pixels, converting each one to LAB, and then adjusts the intensities \ref{eq:histEqPixel}, using the new values from the Equalised Histogram. When the pixels' values are adjusted, the implementation has to convert the pixel from LAB back to XYZ \cite{labTOxyz}, and then to RGB \cite{xyzTOrgb}. A clamping operation is performed as well, before finally setting the new value of the pixel.

The last operation performed by the enhancement algorithm is the \textbf{Average Value Blur} filter. It works in RGB colour space, so it does not need to convert the picture. The filter is very easy to implement, it calculates the average value of the pixel, plus the surrounding pixels \ref{eq:avgFilter}. After it loops through every pixel, a blurred image is produced, which is also the final product image of the algorithm.

This Image Enhancement algorithm is very expensive to compute, and will be visibly slow when executed on older computers. It's implementation can be optimised by using an efficient pixel accessing mechanism, such as Java's \textit{WritableRaster}, but it's run time will still be noticeably long. This is due to combining multiple operations, each of them acting on the \textit{whole} image in sequence.

\begin{figure*}[t]
	\centering
	\subfigure[Image 1 Original]{
		\includegraphics[width=0.225\textwidth]{figures//images//image_01.jpg}
	}
	\subfigure[Image 1 Modified]{
		\includegraphics[width=0.225\textwidth]{figures//images//image_01_changed.jpg}
	} 
	\subfigure[Image 2 Original]{
		\includegraphics[width=0.225\textwidth]{figures//images//image_02.jpg}
	}
	\subfigure[Image 2 Modified]{
		\includegraphics[width=0.225\textwidth]{figures//images//image_02_changed.jpg}
	} \\
	\subfigure[Image 3 Original]{
		\includegraphics[width=0.225\textwidth]{figures//images//image_03.jpg}
	}
	\subfigure[Image 3 Modified]{
		\includegraphics[width=0.225\textwidth]{figures//images//image_03_changed.jpg}
	} 
	\subfigure[Image 4 Original]{
		\includegraphics[width=0.225\textwidth]{figures//images//image_04.jpg}
	}
	\subfigure[Image 4 Modified]{
		\includegraphics[width=0.225\textwidth]{figures//images//image_04_changed.jpg}
	} \\
	\subfigure[Image 5 Original]{
		\includegraphics[width=0.225\textwidth]{figures//images//image_05.jpg}
	}
	\subfigure[Image 5 Modified]{
		\includegraphics[width=0.225\textwidth]{figures//images//image_05_changed.jpg}
	} \\
\caption{Results of performing the mean alignment algorithm on each of the five test images.  For the first two images (a, c), the algorithm produces washed out results (b, d).  Performing the algorithm on Image 3 (e) causes a drastic change in colour (f), whereas the results for Image 4 (g) are far more natural (h).  The effect of the algorithm is least noticeable on Image 5 (i, j). 
	Results of performing the described image enhancement algorithm on each of the five test images. The effect of the algorithm is noticeable in all of the images, they are all brighter and the blur is visible. For images (e, g) the images produced do not look natural (f, h). The algorithm's effect on image (a) has brought in colours in the sky that are not in the original picture (b). For images (c, i) the algorithm produced more natural-looking results. }
\label{fig:results}
\end{figure*}

\begin{figure}[b]
	\centering
	\subfigure[original] {
		\includegraphics[width=0.2\textwidth]{figures/image_01_pre_enh_combined_hist.png}
	}
	\subfigure[modified] {
		\includegraphics[width=0.2\textwidth]{figures/image_01_post_enh_combined_hist.png}
	}
\caption{Average RGB histograms from image 1 (Figure \ref{fig:results} (a, b)).  The unnatural colours occurs, because the original pixel intensity distribution is mostly focused in a particular range, surrounded by a black square, but after contrast adjustment the full range is used, bringing out unnatural colours.}
\label{fig:image01_hists}
\end{figure}

\begin{figure}[b]
	\centering
	\subfigure[low brightness] {
		\includegraphics[width=0.2\textwidth]{figures/low_brightness_hist.png}
	}
	\subfigure[high brightness] {
		\includegraphics[width=0.2\textwidth]{figures/high_brightness_hist.png}
	}
	\caption{Luminosity channel histograms of a low brightness picture (left) and high brightness picture (right).}
	\label{fig:luminDiffHist}
\end{figure}

\section{Results}
\label{sec:results}
%ADD blur might be too much on small pictures, might be too weak on large
The proposed image enhancement method is tested on the five provided images. The results of performing the algorithm is shown in Figure \ref{fig:results}.

The image enhancement algorithm causes a change in all of the images. 
The least change is seen in Image 5 (Figure \ref{fig:results} (i, j)). The most natural looking images are Image 2 and Image 5; in the rest of the images there are large colour changes, bringing out unnatural colours. The blur from the filter is noticeable in all of the images.

The modified version of Images 1, 3 and 4, all have unnatural colours appear. This is due to the Automatic Contrast Adjustment remapping the images to use all of the available intensities, when the original picture pixels' intensity was mostly concentrated on a particular range. This can be seen when looking at the histograms. Figure \ref{fig:image01_hists} shows the histogram before and after processing Image 1. We can see how before the algorithm, the image's pixel intensity values were focused mostly in a particular range, but after being processed by the algorithm, they are spread out, bringing out colours, that would not be very well visible in the original picture.

The second operation in the algorithm, the Histogram Equalisation on the Luminosity channel, is responsible for the pictures looking clearer than the original, and the brightness change that can be seen in all of them. Images 1 and 2 have had their brightness increased after being processed, due to the original picture being dim. Images 4 and 5, have only a slight difference from the original picture's brightness. However, since they appear to be a bit washed out in the original pictures, after equalisation it can be see that they are clearer and less washed out. The same effect appears on Image 3, but it is even weaker. Images 3, 4 and 5 have not been significantly changed by the Luminosity channel Histogram Equalisation, because the original pictures are fairly well exposed and have good brightness.

The final operation in the algorithm, the Average Value Blur filter is responsible for the visible blur in the pictures. The blur might be a little bit too strong than desirable, because the pictures are small in size.

%ADD Luminosity equalisation changes the brightness of all the pictures and adjusts it to such brightness which a well exposed picture would have. if it's too bright it will bring the brightness down, but no such cases here

\section{Discussion \& Conclusions}
\label{sec:discussion}

The results show that the proposed method works best when the picture isn't heavily focused on one colour, causing the Automatic Contrast Adjustment to bring out unnatural colours, that are not seen in the original pictures. If pictures appear to be dim, or washed out, the method will adjust them to appear as if they were well exposed, brighter/less washed out. 
The Average Value Blur filter can be very strong on small pictures, reducing their quality rather than enhancing it, and unnoticeable on large pictures, making it rather unnecessary. The picture sizes are small, that is why the blur effect is a bit stronger than what would be optimal.

From that we can conclude that the algorithm works well with pictures that do not have a single dominating colour. If the pictures happen to be underexposed and appear to be dim or overexposed and washed out, the method will work well, and will properly adjust them. However having the Average Blue Filter's usefulness depend on the picture size is impractical, since we might not have that information.

That makes it one of the areas in which this method can be improved. A different blur filter should be added, one which is consistent and independent of picture size. Another area for improvement might be additional brightness adjustment
The results show that the proposed method works best when there is a small shift observed for each colour channel and the difference in shifts between each colour channel is minimal.  If the shift amount is large, then it is likely that the image will appear washed out and the image's contrast will change.  Also, if the shift amount is very different for each colour channel, then the modified image will contain a very different colour distribution than the original image.   

Therefore, a few key properties of the algorithm can be noted:

\begin{enumerate}
\item The algorithm works best when the shift factor ($\mu_{\mbox{\tiny{ideal}}} - \mu_{\mbox{\tiny{actual}}}$ in Equation 4) is small.  If the shift factor is large then it is likely that a contrast change will be observed.
\item If the distribution of intensities across the different colour channels are very different, then the algorithm will produce an image with colour changes.
\item The algorithm will work best when the distribution of intensities are distributed in an approximately Gaussian distribution. 
\end{enumerate}

With these properties in mind it is possible to outline some possible areas for future improvement.  Firstly, it would be beneficial to incorporate some kind of contrast adjustment \emph{after} the brightness shift has occurred.  This would enable the contrast changes seen in Figure \ref{fig:results} (b) and (d) to be alleviated.  However, it is worth noting that performing a post-processing contrast adjustment would mean that the mean of the target image is no longer aligned to the middle value.

Secondly, the colour problem could be alleviated by performing the shifting operation in a different colour space.  For example, using the HSV colour space would allow for the brightness information to be treated separately from the colour information.  This would reduce the problem to be a single dimensional shift and so the changes in colour that can be seen in the current algorithm could be removed.

Thirdly, the shifting information shown in Table \ref{tbl:shifts} could be used to quantify the effect of the algorithm and so could be used to help guide further processing.  For example, if a low $\delta s$ value is observed then it is likely that no further processing is needed; however, if a high $\delta s$ value is observed then it is likely that the colour information has changed and so further processing, or even different processing, may be required.

In conclusion, this paper has presented a method for automatic image enhancement based on shifting the pixel intensities for each colour channel so that they are mean-aligned to the middle intensity value.  This mid-mean alignment algorithm is intuitive and easy to implement.  In some cases the method is able to improve the quality of the image without any contrast or colour artefacts.  However, in other cases the method, although simple, changes both the colour and the contrast of the image.  This may not be a desirable feature and so further processing, or performing this algorithm in a different colour space, may help overcome these issues.  It is expected that the proposed method could form the basis for a more advanced processing pipeline, and the shift information gained as a result of performing this mid-mean alignment algorithm could give important information to help guide the user in further enhancement processing.

% can use a bibliography generated by BibTeX as a .bbl file
% BibTeX documentation can be easily obtained at:
% http://www.ctan.org/tex-archive/biblio/bibtex/contrib/doc/
% The IEEEtran BibTeX style support page is at:
% http://www.michaelshell.org/tex/ieeetran/bibtex/
\bibliographystyle{IEEEtran}
% argument is your BibTeX string definitions and bibliography database(s)
\bibliography{biblio}


% if you will not have a photo at all:
% that's all folks
\end{document}


